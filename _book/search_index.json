[
["index.html", "A Report Example 1 Prerequsites", " A Report Example Bo Sun 2017-11-18 1 Prerequsites For now, you have to install the development versions of bookdown from Github: devtools::install_github(&quot;rstudio/bookdown&quot;) "],
["t-sne-analysis.html", "2 t-SNE analysis 2.1 Dataset Human 2.2 Dataset Mouse", " 2 t-SNE analysis 2.1 Dataset Human total 163 columns rpkm data kidney 20, 41, 42 miss 1 year kidney 29 miss pre kidney 19 miss 3 months tbl &lt;- tbl_df(tsne$Y) tbl$persons = persons tbl$time_point = Labels tbl %&gt;% ggplot(aes(x = V1, y = V2, label = persons, col = time_point)) + geom_text() Figure 2.1: Similarity between samples and time points(backgroud deducted). Figure @ref{fig:human} shows: The clustering is a lot better after we decuction the pre expression profile from post, 1 year, and 3 months. And is pretty conservative among different seeds and proper perplexity(20-30 tested). Long-time profiles are adjacent to each other and can be separated from the post cluster. For kidney 26, 12, and 22, etc. The post is near the long-time ones, may suggest a better healing ability of the person or a low-level injury?? For kidneys which 1 year is far from 3 months, like 37, 01, 23. May suggest a high-variablity person or kidney-influnced lifystyle…? 23 is a little more interesting, the 3 months is more close to post, which may suggest the long-term influnce comes slow on this person 2.2 Dataset Mouse mouse &lt;- fread(&quot;C:/Users/Ryan/Documents/3.Kidney/MOUSE_all.gene_RPKM.csv&quot;) setnames(mouse, &quot;V1&quot;, &quot;EnsembleID&quot;) mouse.ge &lt;- mouse[, -(1:3)] mouse.ge &lt;- log2(mouse.ge + 1) mouse.ge &lt;- t(mouse.ge) Labels &lt;- colsplit(rownames(mouse.ge), pattern = &quot;-&quot;, names = c(&quot;Mouse&quot;, &quot;grp&quot;))$Mouse ind &lt;- regexpr(&quot;[[:digit:]]&quot;, Labels, perl =T) prefix = c(); time_point = c() for(i in 1:length(Labels)) { prefix &lt;- append(prefix, substr(Labels[i], 1, ind[i] - 1)) time_point &lt;- append(time_point, substr(Labels[i], ind[i], nchar(Labels[i]))) } set.seed(81) tsne &lt;- Rtsne(mouse.ge, dims = 2, perplexity = 9, verbose = T, max_iter = 500) ## Read the 49 x 49 data matrix successfully! ## Using no_dims = 2, perplexity = 9.000000, and theta = 0.500000 ## Computing input similarities... ## Normalizing input... ## Building tree... ## - point 0 of 49 ## Done in 0.00 seconds (sparsity = 0.670554)! ## Learning embedding... ## Iteration 50: error is 56.664756 (50 iterations in 0.01 seconds) ## Iteration 100: error is 51.474400 (50 iterations in 0.01 seconds) ## Iteration 150: error is 56.221535 (50 iterations in 0.01 seconds) ## Iteration 200: error is 54.908899 (50 iterations in 0.01 seconds) ## Iteration 250: error is 56.325644 (50 iterations in 0.01 seconds) ## Iteration 300: error is 1.607589 (50 iterations in 0.01 seconds) ## Iteration 350: error is 0.545783 (50 iterations in 0.00 seconds) ## Iteration 400: error is 0.351512 (50 iterations in 0.00 seconds) ## Iteration 450: error is 0.204200 (50 iterations in 0.01 seconds) ## Iteration 500: error is 0.186298 (50 iterations in 0.00 seconds) ## Fitting performed in 0.06 seconds. tbl &lt;- tbl_df(tsne$Y) tbl$sample_type = prefix tbl$time_point = time_point tbl %&gt;% ggplot(aes(x = V1, y = V2, label = time_point, col = sample_type)) + geom_text() (#fig:tSNE_mouse)Same t-SNE analysis for mouse data. As shown in the Figure @ref{fig:tSNE_mouse}: The syntaxis of same time-point and same mouse-type are stronger in this Mouse data, though it has less sample points here–49 samples in total, divided into three types(IRI, NORM, SHAM), each time point with 3 replicate except for 6mN has 4. The perplexity = 9 and set.seed(81) were tuned mannualy by hands-and-eyes. Based on tens of runs, the results are alike–the clustering is good. Perplexity &gt;5 and &lt;= 10 generally works here for limitied times of run done by myself. "],
["quality-control.html", "3 Quality Control 3.1 gene filtering 3.2 check log-nomality", " 3 Quality Control Note that Monocle assume the gene expresison is log-normally distributed. So here we perform some filtering and then give it a check. 3.1 gene filtering human &lt;- detectGenes(human, min_expr = 0.1) plot(density(fData(human)$num_cells_expressed)) The number of cells express a certain gene is bimodal distributed, for \\(threshold = .1\\), some genes are expressed in all 163 samples, and some genes are only expressed in a little few samples. expressed.gene &lt;- row.names(subset(fData(human), num_cells_expressed &gt;= 50)) Genes has &gt;= 50 samples with \\(RPKM &gt;= .1\\) are kept. (22047/54514 genes left) 3.2 check log-nomality As suggest in Monocle mannual, take log(rpkm + 1), scale each log-transformed gene expression(subtract the mean and divided by \\(sd\\)), make the whole log-rpkm matrix a single vector then compare it to a standard normal. L &lt;- log(exprs(human[expressed.gene,]) + 1) Apparently, our filtered data pass the log-normality test. I don’t understand why do we need to scale log-transformed rpkm for each gene and then make the matrix a single “log-expr matrix”. Because in our first project about Huber regerssion, we claim the RPKM to be heavy-tailed by examining every single gene. Why Monocle assume that the whole matrix has a log-normally distribution, instead of examning each gene? And why even scale then compare, wouldn’t it be all normal-like by CLT if we scale it? So here is the un-scaling version. "],
["pseudo-time-trajectory-prediction.html", "4 Pseudo-time trajectory prediction 4.1 Set ordering genes to be used in Monocle’s trajectory construction", " 4 Pseudo-time trajectory prediction 4.1 Set ordering genes to be used in Monocle’s trajectory construction diff_test_res &lt;- differentialGeneTest(human[expressed.gene,], fullModelFormulaStr = &quot;~time&quot;) ordering_genes &lt;- row.names (subset(diff_test_res, qval &lt; 0.01)) ordering_genes &lt;- intersect(ordering_genes, expressed.gene) human &lt;- setOrderingFilter(human, ordering_genes) human &lt;- reduceDimension(human, max_components = 2, method = &#39;DDRTree&#39;) human &lt;- orderCells(human) ## Warning in (ap %*% ab)/(ab %*% ab) * ab: Recycling array of length 1 in array-vector arithmetic is deprecated. ## Use c() or as.vector() instead. ## Warning in (ap %*% ab)/(ab %*% ab) * ab: Recycling array of length 1 in array-vector arithmetic is deprecated. ## Use c() or as.vector() instead. ## Warning in (ap %*% ab)/(ab %*% ab) * ab: Recycling array of length 1 in array-vector arithmetic is deprecated. ## Use c() or as.vector() instead. ## Warning in (ap %*% ab)/(ab %*% ab) * ab: Recycling array of length 1 in array-vector arithmetic is deprecated. ## Use c() or as.vector() instead. ## Warning in (ap %*% ab)/(ab %*% ab) * ab: Recycling array of length 1 in array-vector arithmetic is deprecated. ## Use c() or as.vector() instead. ## Warning in (ap %*% ab)/(ab %*% ab) * ab: Recycling array of length 1 in array-vector arithmetic is deprecated. ## Use c() or as.vector() instead. ## Warning in (ap %*% ab)/(ab %*% ab) * ab: Recycling array of length 1 in array-vector arithmetic is deprecated. ## Use c() or as.vector() instead. ## Warning in (ap %*% ab)/(ab %*% ab) * ab: Recycling array of length 1 in array-vector arithmetic is deprecated. ## Use c() or as.vector() instead. ## Warning in (ap %*% ab)/(ab %*% ab) * ab: Recycling array of length 1 in array-vector arithmetic is deprecated. ## Use c() or as.vector() instead. ## Warning in (ap %*% ab)/(ab %*% ab) * ab: Recycling array of length 1 in array-vector arithmetic is deprecated. ## Use c() or as.vector() instead. ## Warning in (ap %*% ab)/(ab %*% ab) * ab: Recycling array of length 1 in array-vector arithmetic is deprecated. ## Use c() or as.vector() instead. ## Warning in (ap %*% ab)/(ab %*% ab) * ab: Recycling array of length 1 in array-vector arithmetic is deprecated. ## Use c() or as.vector() instead. ## Warning in (ap %*% ab)/(ab %*% ab) * ab: Recycling array of length 1 in array-vector arithmetic is deprecated. ## Use c() or as.vector() instead. ## Warning in (ap %*% ab)/(ab %*% ab) * ab: Recycling array of length 1 in array-vector arithmetic is deprecated. ## Use c() or as.vector() instead. ## Warning in (ap %*% ab)/(ab %*% ab) * ab: Recycling array of length 1 in array-vector arithmetic is deprecated. ## Use c() or as.vector() instead. ## Warning in (ap %*% ab)/(ab %*% ab) * ab: Recycling array of length 1 in array-vector arithmetic is deprecated. ## Use c() or as.vector() instead. ## Warning in (ap %*% ab)/(ab %*% ab) * ab: Recycling array of length 1 in array-vector arithmetic is deprecated. ## Use c() or as.vector() instead. ## Warning in (ap %*% ab)/(ab %*% ab) * ab: Recycling array of length 1 in array-vector arithmetic is deprecated. ## Use c() or as.vector() instead. ## Warning in (ap %*% ab)/(ab %*% ab) * ab: Recycling array of length 1 in array-vector arithmetic is deprecated. ## Use c() or as.vector() instead. ## Warning in (ap %*% ab)/(ab %*% ab) * ab: Recycling array of length 1 in array-vector arithmetic is deprecated. ## Use c() or as.vector() instead. ## Warning in (ap %*% ab)/(ab %*% ab) * ab: Recycling array of length 1 in array-vector arithmetic is deprecated. ## Use c() or as.vector() instead. ## Warning in (ap %*% ab)/(ab %*% ab) * ab: Recycling array of length 1 in array-vector arithmetic is deprecated. ## Use c() or as.vector() instead. ## Warning in (ap %*% ab)/(ab %*% ab) * ab: Recycling array of length 1 in array-vector arithmetic is deprecated. ## Use c() or as.vector() instead. ## Warning in (ap %*% ab)/(ab %*% ab) * ab: Recycling array of length 1 in array-vector arithmetic is deprecated. ## Use c() or as.vector() instead. ## Warning in (ap %*% ab)/(ab %*% ab) * ab: Recycling array of length 1 in array-vector arithmetic is deprecated. ## Use c() or as.vector() instead. ## Warning in (ap %*% ab)/(ab %*% ab) * ab: Recycling array of length 1 in array-vector arithmetic is deprecated. ## Use c() or as.vector() instead. ## Warning in (ap %*% ab)/(ab %*% ab) * ab: Recycling array of length 1 in array-vector arithmetic is deprecated. ## Use c() or as.vector() instead. ## Warning in (ap %*% ab)/(ab %*% ab) * ab: Recycling array of length 1 in array-vector arithmetic is deprecated. ## Use c() or as.vector() instead. ## Warning in (ap %*% ab)/(ab %*% ab) * ab: Recycling array of length 1 in array-vector arithmetic is deprecated. ## Use c() or as.vector() instead. ## Warning in (ap %*% ab)/(ab %*% ab) * ab: Recycling array of length 1 in array-vector arithmetic is deprecated. ## Use c() or as.vector() instead. ## Warning in (ap %*% ab)/(ab %*% ab) * ab: Recycling array of length 1 in array-vector arithmetic is deprecated. ## Use c() or as.vector() instead. ## Warning in (ap %*% ab)/(ab %*% ab) * ab: Recycling array of length 1 in array-vector arithmetic is deprecated. ## Use c() or as.vector() instead. ## Warning in (ap %*% ab)/(ab %*% ab) * ab: Recycling array of length 1 in array-vector arithmetic is deprecated. ## Use c() or as.vector() instead. ## Warning in (ap %*% ab)/(ab %*% ab) * ab: Recycling array of length 1 in array-vector arithmetic is deprecated. ## Use c() or as.vector() instead. ## Warning in (ap %*% ab)/(ab %*% ab) * ab: Recycling array of length 1 in array-vector arithmetic is deprecated. ## Use c() or as.vector() instead. ## Warning in (ap %*% ab)/(ab %*% ab) * ab: Recycling array of length 1 in array-vector arithmetic is deprecated. ## Use c() or as.vector() instead. ## Warning in (ap %*% ab)/(ab %*% ab) * ab: Recycling array of length 1 in array-vector arithmetic is deprecated. ## Use c() or as.vector() instead. ## Warning in (ap %*% ab)/(ab %*% ab) * ab: Recycling array of length 1 in array-vector arithmetic is deprecated. ## Use c() or as.vector() instead. ## Warning in (ap %*% ab)/(ab %*% ab) * ab: Recycling array of length 1 in array-vector arithmetic is deprecated. ## Use c() or as.vector() instead. ## Warning in (ap %*% ab)/(ab %*% ab) * ab: Recycling array of length 1 in array-vector arithmetic is deprecated. ## Use c() or as.vector() instead. ## Warning in (ap %*% ab)/(ab %*% ab) * ab: Recycling array of length 1 in array-vector arithmetic is deprecated. ## Use c() or as.vector() instead. ## Warning in (ap %*% ab)/(ab %*% ab) * ab: Recycling array of length 1 in array-vector arithmetic is deprecated. ## Use c() or as.vector() instead. ## Warning in (ap %*% ab)/(ab %*% ab) * ab: Recycling array of length 1 in array-vector arithmetic is deprecated. ## Use c() or as.vector() instead. ## Warning in (ap %*% ab)/(ab %*% ab) * ab: Recycling array of length 1 in array-vector arithmetic is deprecated. ## Use c() or as.vector() instead. ## Warning in (ap %*% ab)/(ab %*% ab) * ab: Recycling array of length 1 in array-vector arithmetic is deprecated. ## Use c() or as.vector() instead. 17985 of 22047 genes left. (The 22047 genes are the genes that pass the fitering described in 3.1). plot_cell_trajectory(human, color_by = &quot;time&quot;) plot_cell_trajectory(human, color_by = &quot;Pseudotime&quot;) Figure 4.1: Same trajectory colored by Pseudotime Monocle doesn’t know a priori which of the trajectory of the tree to call the “beginning”. So the Pseudotime is plotted reversly. It’s a little bit tricky to make it right. But in our case, it’s clear that the left is beginning and the right is end since the left points are pre and right points are post, as suggested in the previous figuer. "]
]
